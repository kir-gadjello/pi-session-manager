---
id: "2026-01-31-实现会话列表自动刷新和状态 Badge 功能"
title: "实现会话列表自动刷新和状态 Badge 功能"
status: "in-progress"
created: "2026-01-31"
updated: "2026-01-31"
category: "feature"
tags: ["auto-refresh", "badge", "ux-improvement"]
---

# Issue: 实现会话列表自动刷新和状态 Badge 功能

## Goal

前端自动刷新会话列表，并通过 Badge 区分新增和更新的会话，提升用户体验。

## 背景/问题

**当前状态：**
- ✅ 后端：有后台扫描器，每 30 秒自动扫描并更新 SQLite 缓存
- ❌ 前端：没有自动刷新机制，需要手动按 `Cmd+R` 刷新
- ❌ 无法区分哪些会话是新增的，哪些是更新的

**用户需求：**
1. 会话列表应该自动更新，无需手动刷新
2. 新增的会话显示 "NEW" badge
3. 更新的会话显示 "UPDATED" badge

## 验收标准 (Acceptance Criteria)

- [ ] WHEN 后台扫描器检测到新会话，前端 SHALL 在 30-60 秒内自动刷新列表
- [ ] WHEN 会话是新增的（首次出现），SHALL 显示 "NEW" badge（绿色）
- [ ] WHEN 会话内容被更新（message_count 增加），SHALL 显示 "UPDATED" badge（蓝色）
- [ ] WHEN 用户查看过会话后，badge SHALL 自动消失
- [ ] WHERE 用户手动刷新（Cmd+R），badge 状态 SHALL 正确更新

## 实施阶段

### Phase 1: 规划和准备
- [x] 分析当前架构（后端有扫描器，前端缺自动刷新）
- [x] 设计技术方案（轮询 + 本地状态追踪）
- [x] 确定实施计划

### Phase 2: 执行
- [ ] 后端：添加 `get_session_updates` 命令，返回新增/更新的会话 ID
- [ ] 后端：在 SQLite 中添加 `first_seen_at` 字段，用于判断是否新增
- [ ] 前端：实现自动刷新 Hook（每 30 秒轮询）
- [ ] 前端：实现 Badge 组件（NEW/UPDATED）
- [ ] 前端：在 SessionList 中集成 Badge
- [ ] 前端：实现查看后清除 Badge 的逻辑

### Phase 3: 验证
- [ ] 测试自动刷新功能
- [ ] 测试 Badge 显示逻辑
- [ ] 测试 Badge 清除逻辑
- [ ] 代码审查

### Phase 4: 交付
- [ ] 更新文档
- [ ] 创建 PR
- [ ] 合并主分支

## 关键决策

| 决策 | 理由 |
|------|------|
| ~~使用轮询而非 WebSocket~~ **改用文件系统监听（notify）** | 更实时、更高效，文件变化立即触发更新，无需轮询 |
| Badge 状态存储在 localStorage | 避免后端复杂度，前端自主管理查看状态 |
| 使用 `first_seen_at` 判断新增 | SQLite 已有 `cached_at`，但需要区分首次缓存和更新 |
| Badge 在查看后自动消失 | 减少视觉噪音，用户查看即表示已知晓 |
| 使用 Tauri 事件系统通知前端 | 后端监听文件变化，通过事件推送给前端，避免轮询 |

## 技术方案

### 1. 后端改动

#### 1.1 数据库 Schema 更新
```sql
ALTER TABLE sessions ADD COLUMN first_seen_at TEXT;
ALTER TABLE sessions ADD COLUMN last_updated_at TEXT;
```

#### 1.2 新增 Tauri 命令
```rust
#[tauri::command]
pub async fn get_session_updates(last_check: String) -> Result<SessionUpdates, String> {
    // 返回自 last_check 以来新增和更新的会话
}
```

### 2. 前端改动

#### 2.1 自动刷新 Hook
```typescript
function useAutoRefresh(interval: number = 30000) {
  useEffect(() => {
    const timer = setInterval(() => {
      loadSessions()
    }, interval)
    return () => clearInterval(timer)
  }, [])
}
```

#### 2.2 Badge 组件
```typescript
function SessionBadge({ type }: { type: 'new' | 'updated' }) {
  return (
    <span className={`badge ${type}`}>
      {type === 'new' ? 'NEW' : 'UPDATED'}
    </span>
  )
}
```

#### 2.3 Badge 状态管理
```typescript
// localStorage: { sessionId: { viewed: boolean, firstSeen: timestamp } }
const [badgeStates, setBadgeStates] = useState<Record<string, BadgeState>>({})
```

## 遇到的错误

| 日期 | 错误 | 解决方案 |
|------|------|---------|
| - | - | - |

## 相关资源

- [x] 相关文档: `docs/architecture/storage-architecture.md`（待创建）
- [x] 相关代码: `src-tauri/src/scanner_scheduler.rs`
- [x] 相关代码: `src/App.tsx`

## Notes

**实现优先级：**
1. 先实现前端自动刷新（简单，立即可用）
2. 再实现 Badge 功能（需要后端配合）

**简化方案（快速实现）：**
- 前端：直接使用 `setInterval` 每 30 秒调用 `scan_sessions()`
- Badge：前端对比前后两次 sessions 数组，判断新增/更新
- 状态：使用 localStorage 存储已查看的会话 ID

---

## Status 更新日志

- **2026-01-31 15:20**: 状态变更 → in-progress，备注: 开始实施